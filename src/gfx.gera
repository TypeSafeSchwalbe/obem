
mod obem::gfx

use obem::internal::gfx::*

pub proc Mesh(data, indices) { return {
    handle = internal_create_mesh(data, indices)
} }

pub proc Shader(vertex_src, fragment_src) { return {
    handle = internal_create_shader(vertex_src, fragment_src),

    set_uniform_flt = |self, name, value| {
        internal_set_uniform_flt(self.handle, name, value)
        return self
    },
    set_uniform_flt_arr = |self, name, values| {
        internal_set_uniform_flt_arr(self.handle, name, values)
        return self
    },

    set_uniform_int = |self, name, value| {
        internal_set_uniform_int(self.handle, name, value)
        return self
    },
    set_uniform_int_arr = |self, name, values| {
        internal_set_uniform_int_arr(self.handle, name, values)
        return self
    },

    set_uniform_vec = |self, name, value| {
        internal_set_uniform_vec(self.handle, name, value)
        return self
    },
    set_uniform_vec_arr = |self, name, values| {
        internal_set_uniform_vec_arr(self.handle, name, values)
        return self
    },

    set_uniform_mat = |self, name, value| {
        internal_set_uniform_mat(self.handle, name, value)
        return self
    },
    set_uniform_mat_arr = |self, name, values| {
        internal_set_uniform_mat_arr(self.handle, name, values)
        return self
    },

    set_uniform_tex = |self, name, value| {
        internal_set_uniform_tex(self.handle, name, value.handle)
        return self
    },
    set_uniform_tex_arr = |self, name, values| {
        case length(values) == 0 -> return self
        var value_handles = array(values[0].handle, length(values))
        0..length(value_handles) |> std::iter::for_each(|i| {
            value_handles[i] = values[i].handle
        })
        internal_set_uniform_tex_arr(self.handle, name, value_handles)
        return self
    }
} }

pub proc Texture(width, height) {
    case width < 0 || height < 0 -> panic("Invalid texture dimensions!")
    return {
        handle = internal_create_texture(width, height),

        width = |self| width,
        height = |self| height
    }
}

proc create_surface(handle) { return {
    handle = handle,

    width = |self| internal_surface_width(self.handle),
    height = |self| internal_surface_height(self.handle),

    clear_color = |self, r, g, b, a| {
        internal_clear_color(self.handle, r, g, b, a)
        return self
    },

    clear_depth = |self, d| {
        internal_clear_depth(self.handle, d)
        return self
    }
} }

pub proc main_surface() {
    return create_surface(internal_main_surface())
}

pub proc Surface(texture) {
    return create_surface(internal_create_surface(texture))
}

pub proc render(mesh, vertex_property_sizes, shader, depth_test, surface) {
    internal_render(
        mesh.handle, vertex_property_sizes, shader.handle, depth_test,
        surface.handle
    )
}